import crypto from "crypto";
import { storage } from "../storage";
import { type InsertProduct } from "@shared/schema";

interface AmazonProduct {
  asin: string;
  title: string;
  description: string;
  imageUrl: string;
  affiliateLink: string;
  price?: string;
  rating?: number;
  reviewCount?: number;
}

export class AmazonService {
  private async getApiSettings() {
    const envPartnerId = process.env.AMAZON_PARTNER_ID;
    const envApiKey = process.env.AMAZON_API_KEY;
    const envSecretKey = process.env.AMAZON_SECRET_KEY;

    if (envPartnerId && envApiKey && envSecretKey) {
      return {
        partnerId: envPartnerId,
        apiKey: envApiKey,
        secretKey: envSecretKey,
      };
    }

    throw new Error("Amazon API settings not found in environment variables");
  }

  private async signedAmazonRequest(
    target: string,
    payload: any,
    settings: { apiKey: string; secretKey: string; partnerId: string },
  ): Promise<Response> {
    const host = "webservices.amazon.com";
    const uri = `/${target}`;
    const amzDate = new Date().toISOString().replace(/[:-]|\.\d{3}/g, "");
    const dateStamp = amzDate.slice(0, 8);
    const region = "us-east-1";
    const service = "ProductAdvertisingAPI";
    const algorithm = "AWS4-HMAC-SHA256";

    const opMap = {
      getitems: "GetItems",
      searchitems: "SearchItems",
    };

    const opKey = target.split("/")[1].toLowerCase(); // safely lowercased
    const opName = opMap[opKey]; // reliably mapped to correct casing

    const headers: Record<string, string> = {
      host,
      "content-type": "application/json; charset=utf-8",
      "content-encoding": "amz-1.0",
      "x-amz-target": `com.amazon.paapi5.v1.ProductAdvertisingAPIv1.${opName}`,
      "x-amz-date": amzDate,
    };

    const payloadString = JSON.stringify(payload);
    const payloadHash = crypto
      .createHash("sha256")
      .update(payloadString)
      .digest("hex");

    const canonicalHeaders =
      Object.keys(headers)
        .sort()
        .map((key) => `${key}:${headers[key]}`)
        .join("\n") + "\n";

    const signedHeaders = Object.keys(headers).sort().join(";");

    const canonicalRequest = [
      "POST",
      uri,
      "",
      canonicalHeaders,
      signedHeaders,
      payloadHash,
    ].join("\n");

    const credentialScope = `${dateStamp}/${region}/${service}/aws4_request`;
    const stringToSign = [
      algorithm,
      amzDate,
      credentialScope,
      crypto.createHash("sha256").update(canonicalRequest).digest("hex"),
    ].join("\n");

    const kDate = crypto
      .createHmac("sha256", `AWS4${settings.secretKey}`)
      .update(dateStamp)
      .digest();
    const kRegion = crypto.createHmac("sha256", kDate).update(region).digest();
    const kService = crypto
      .createHmac("sha256", kRegion)
      .update(service)
      .digest();
    const kSigning = crypto
      .createHmac("sha256", kService)
      .update("aws4_request")
      .digest();

    const signature = crypto
      .createHmac("sha256", kSigning)
      .update(stringToSign)
      .digest("hex");

    const authorizationHeader = `${algorithm} Credential=${settings.apiKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;

    return fetch(`https://${host}${uri}`, {
      method: "POST",
      headers: {
        ...headers,
        Authorization: authorizationHeader,
        "Content-Length": Buffer.byteLength(payloadString).toString(),
      },
      body: payloadString,
    });
  }

  /**
   * Search for products on Amazon using the Partner API.
   *
   * This method performs the following steps:
   * 1. Retrieves 100 products from Amazon.
   * 2. Maps each product to include rating and review count.
   * 3. Filters out products that:
   *    - Are not considered "main" products (using isMainProduct).
   *    - Have a title match score of 0 (i.e. no keyword overlap).
   * 4. Sorts the remaining products by:
   *    - Highest title match quality first.
   *    - Then by highest rating.
   *    - Then by the highest review count.
   * 5. Returns the first 5 products.
   *
   * Note: This approach first prioritizes title match while keeping criteria loose,
   * and then ranks by rating and review count.
   */
  async searchProducts(
    keyword: string,
    count: number = 5,
  ): Promise<AmazonProduct[]> {
    try {
      const settings = await this.getApiSettings();
      console.log(`Searching Amazon for keyword: ${keyword}`);

      if (!settings) {
        throw new Error("Amazon API settings are not available");
      }

      // API endpoint details
      const host = "webservices.amazon.com";
      const region = "us-east-1";
      const uri = "/paapi5/searchitems";
      const service = "ProductAdvertisingAPI";

      console.log(
        `Using Amazon credentials - Partner ID: ${settings.partnerId}, API Key: [masked]`,
      );

      // Get the current time in ISO format for request signing
      const amzDate = new Date().toISOString().replace(/[:-]|\.\d{3}/g, "");
      const dateStamp = amzDate.slice(0, 8);

      // Request payload: retrieve 100 items initially
      const initialItemCount = 100;
      const payload = JSON.stringify({
        Keywords: keyword,
        Resources: [
          "BrowseNodeInfo.BrowseNodes",
          "BrowseNodeInfo.BrowseNodes.Ancestor",
          "BrowseNodeInfo.BrowseNodes.SalesRank",
          "BrowseNodeInfo.WebsiteSalesRank",
          "CustomerReviews.Count",
          "CustomerReviews.StarRating",
          "Images.Primary.Large",
          "Images.Primary.HighRes",
          "ItemInfo.ByLineInfo",
          "ItemInfo.ContentInfo",
          "ItemInfo.ContentRating",
          "ItemInfo.Classifications",
          "ItemInfo.ExternalIds",
          "ItemInfo.Features",
          "ItemInfo.ProductInfo",
          "ItemInfo.TechnicalInfo",
          "ItemInfo.Title",
          "Offers.Listings.Availability.MaxOrderQuantity",
          "Offers.Listings.Availability.Message",
          "Offers.Listings.Availability.MinOrderQuantity",
          "Offers.Listings.Availability.Type",
          "Offers.Listings.Condition",
          "Offers.Listings.Condition.ConditionNote",
          "Offers.Listings.Condition.SubCondition",
          "Offers.Listings.DeliveryInfo.IsAmazonFulfilled",
          "Offers.Listings.DeliveryInfo.IsFreeShippingEligible",
          "Offers.Listings.DeliveryInfo.IsPrimeEligible",
          "Offers.Listings.DeliveryInfo.ShippingCharges",
          "Offers.Listings.IsBuyBoxWinner",
          "Offers.Listings.LoyaltyPoints.Points",
          "Offers.Listings.MerchantInfo",
          "Offers.Listings.Price",
          "Offers.Listings.ProgramEligibility.IsPrimeExclusive",
          "Offers.Listings.ProgramEligibility.IsPrimePantry",
          "Offers.Listings.Promotions",
          "Offers.Listings.SavingBasis",
          "Offers.Summaries.HighestPrice",
          "Offers.Summaries.LowestPrice",
          "Offers.Summaries.OfferCount",
          "ParentASIN",
          "SearchRefinements",
        ],
        PartnerTag: settings.partnerId,
        PartnerType: "Associates",
        Marketplace: "www.amazon.com",
        ItemCount: initialItemCount,
        Condition: "New",
        SearchIndex: "All",
      });

      // Create request headers based on API specifications
      const algorithm = "AWS4-HMAC-SHA256";
      const headers: Record<string, string> = {
        host: host,
        "content-type": "application/json; charset=utf-8",
        "content-encoding": "amz-1.0",
        "x-amz-target":
          "com.amazon.paapi5.v1.ProductAdvertisingAPIv1.SearchItems",
        "x-amz-date": amzDate,
      };

      // Build the canonical headers and signed headers strings for signing
      const canonicalHeaders =
        Object.keys(headers)
          .sort()
          .map((key) => `${key}:${headers[key]}`)
          .join("\n") + "\n";
      const signedHeaders = Object.keys(headers).sort().join(";");

      // Create the canonical request
      const payloadHash = crypto
        .createHash("sha256")
        .update(payload)
        .digest("hex");
      const canonicalRequest = [
        "POST",
        uri,
        "",
        canonicalHeaders,
        signedHeaders,
        payloadHash,
      ].join("\n");

      // Build the string to sign
      const credentialScope = `${dateStamp}/${region}/${service}/aws4_request`;
      const stringToSign = [
        algorithm,
        amzDate,
        credentialScope,
        crypto.createHash("sha256").update(canonicalRequest).digest("hex"),
      ].join("\n");

      // Calculate the signature
      const kDate = crypto
        .createHmac("sha256", `AWS4${settings.secretKey}`)
        .update(dateStamp)
        .digest();
      const kRegion = crypto
        .createHmac("sha256", kDate)
        .update(region)
        .digest();
      const kService = crypto
        .createHmac("sha256", kRegion)
        .update(service)
        .digest();
      const kSigning = crypto
        .createHmac("sha256", kService)
        .update("aws4_request")
        .digest();
      const signature = crypto
        .createHmac("sha256", kSigning)
        .update(stringToSign)
        .digest("hex");

      // Create the authorization header
      const authorizationHeader = `${algorithm} Credential=${settings.apiKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;

      // Make the API request to Amazon
      const url = `https://${host}${uri}`;
      console.log(`Making Amazon API request to: ${url}`);
      console.log(
        `Request headers:`,
        JSON.stringify(
          {
            ...headers,
            Authorization: authorizationHeader.substring(0, 60) + "...",
            "Content-Length": Buffer.byteLength(payload).toString(),
          },
          null,
          2,
        ),
      );
      console.log(`Request payload: ${payload}`);

      let allItems: any[] = [];

      for (let page = 1; page <= 7; page++) {
        if (page > 1) {
          console.log(`Waiting 1100ms before fetching page ${page}...`);
        }
        await this.sleep(1100);
        const pagePayload = JSON.stringify({
          Keywords: keyword,
          PartnerTag: settings.partnerId,
          PartnerType: "Associates",
          Marketplace: "www.amazon.com",
          ItemCount: 10,
          ItemPage: page,
          Condition: "New",
          SearchIndex: "All",
          SortBy: "Featured",
          Resources: [
            "ItemInfo.Title",
            "CustomerReviews.StarRating",
            "CustomerReviews.Count",
            "Images.Primary.Large",
            "ItemInfo.ByLineInfo",
          ],
        });

        const payloadHash = crypto
          .createHash("sha256")
          .update(pagePayload)
          .digest("hex");
        const canonicalRequest = [
          "POST",
          uri,
          "",
          canonicalHeaders,
          signedHeaders,
          payloadHash,
        ].join("\n");

        const stringToSign = [
          algorithm,
          amzDate,
          credentialScope,
          crypto.createHash("sha256").update(canonicalRequest).digest("hex"),
        ].join("\n");

        const signature = crypto
          .createHmac("sha256", kSigning)
          .update(stringToSign)
          .digest("hex");
        const authorizationHeaderPaged = `${algorithm} Credential=${settings.apiKey}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${signature}`;

        const response = await fetch(url, {
          method: "POST",
          headers: {
            ...headers,
            Authorization: authorizationHeaderPaged,
            "Content-Length": Buffer.byteLength(pagePayload).toString(),
          },
          body: pagePayload,
        });

        if (!response.ok) {
          console.warn(
            `Page ${page} failed with status ${response.status}. Response:`,
            {
              status: response.status,
              statusText: response.statusText,
              headers: Object.fromEntries(response.headers.entries()),
              body: await response
                .text()
                .catch((e) => `Failed to read body: ${e}`),
            },
          );
          console.warn("Request details:", {
            url,
            pagePayload: JSON.parse(pagePayload),
            headers: {
              ...headers,
              Authorization: "[masked]",
              "Content-Length": Buffer.byteLength(pagePayload).toString(),
            },
          });
          continue;
        }

        const data = await response.json();
        const items = data.SearchResult?.Items || [];
        allItems.push(...items);

        // Early exit if fewer than 10 results returned
        if (items.length < 10) break;
      }

      console.log(`Collected ${allItems.length} items from all pages`);

      // --- NEW: get richer data for every ASIN we just found ---
      // Do initial filtering with search data
      // Get details for all collected items first
      const allAsins = allItems.map((item: any) => item.ASIN);
      const enrichedProducts = await this.getItemsDetails(allAsins);

      allProducts.forEach(p => {
        const reasons = [];

        if (!p.title || !p.affiliateLink) {
          reasons.push("Missing title or affiliate link");
        }

        const score = this.scoreProduct(p, keyword);
        if (score === 0) {
          reasons.push("No keyword match in title");
        }

        const isMain = this.isMainProduct(p, keyword);
        if (!isMain) {
          reasons.push("Detected as accessory");
        }

        if ((p.rating ?? 0) < 4.3) {
          reasons.push(`Rating too low: ${p.rating}`);
        }

        if ((p.reviewCount ?? 0) < 100) {
          reasons.push(`Not enough reviews: ${p.reviewCount}`);
        }

        if (p.isBuyBoxWinner !== true) {
          reasons.push("BuyBox not won");
        }

        if (!["NOW", "IN_STOCK"].includes((p.availabilityType ?? "").toUpperCase())) {
          reasons.push(`Not in stock (availabilityType = ${p.availabilityType})`);
        }

        if (reasons.length > 0) {
          console.log(`❌ Excluding ASIN ${p.asin} - ${p.title}`);
          console.log("Reasons:", reasons.join("; "));
        }
      });

      // Now score and filter with complete data
      const scoredProducts = enrichedProducts
        .filter((p) => p.title && p.affiliateLink) // Basic validation
        .map((product) => ({
          ...product,
          score: this.scoreProduct(product, keyword),
          isMain: this.isMainProduct(product, keyword),
        }))
        .filter(
          (p) =>
            (p.score > 0 &&
              p.isMain &&
              (p.rating ?? 0) >= 4.3 &&
              (p.reviewCount ?? 0) >= 100 &&
              p.isBuyBoxWinner === true && // 👈 new hard‑requirement
              p.availabilityType === "Now") ||
            p.availabilityType === "IN_STOCK",
        )

        .sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          if ((b.rating || 0) !== (a.rating || 0))
            return (b.rating || 0) - (a.rating || 0);
          return (b.reviewCount || 0) - (a.reviewCount || 0);
        });

      const eligibleProducts = scoredProducts.slice(0, count);

      if (eligibleProducts.length === 0) {
        throw new Error(
          `No products found meeting the criteria for keyword "${keyword}"`,
        );
      }

      // Sort eligible products by:
      // 1. Title match quality (scoreProduct),
      // 2. Then by rating (highest first),
      // 3. Then by review count (highest first).
      eligibleProducts.sort((a, b) => {
        const scoreA = this.scoreProduct(a, keyword);
        const scoreB = this.scoreProduct(b, keyword);
        if (scoreB !== scoreA) return scoreB - scoreA;
        if ((b.rating || 0) !== (a.rating || 0))
          return (b.rating || 0) - (a.rating || 0);
        return (b.reviewCount || 0) - (a.reviewCount || 0);
      });

      const topProducts = eligibleProducts.slice(0, count);
      return topProducts;
    } catch (error) {
      console.error("Amazon product search failed:", error);
      if (error instanceof Error) {
        console.error(`Amazon API Error: ${error.message}`);
        console.log(
          "Amazon API requires valid credentials. Please verify your Partner ID, API Key, and Secret Key.",
        );
        throw new Error(`Failed to search Amazon products: ${error.message}`);
      } else {
        throw new Error(`Failed to search Amazon products: Unknown error`);
      }
    }
  }

  /**
   * Add products to storage for a specific article.
   */
  async addProductsToArticle(
    articleId: number,
    products: AmazonProduct[],
  ): Promise<void> {
    for (const product of products) {
      const productData: InsertProduct = {
        articleId,
        asin: product.asin,
        title: product.title,
        description: product.description,
        imageUrl: product.imageUrl,
        affiliateLink: product.affiliateLink,
      };
      await storage.addProduct(productData);
    }
  }

  /**
   * Helper function to capitalize the first letter of each word.
   */
  private capitalizeFirstLetter(str: string): string {
    return str
      .split(" ")
      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
      .join(" ");
  }

  private async sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  async getItemsDetails(asins: string[]): Promise<AmazonProduct[]> {
    const settings = await this.getApiSettings();
    const results: AmazonProduct[] = [];

    for (const asin of asins) {
      const payload = {
        PartnerTag: settings.partnerId,
        PartnerType: "Associates",
        Marketplace: "www.amazon.com",
        ItemIds: [asin],
        Resources: [
          "ItemInfo.Title",
          "ItemInfo.Features",
          "ItemInfo.ProductInfo",
          "ItemInfo.ManufactureInfo",
          "ItemInfo.TechnicalInfo",
          "Offers.Listings.Price",
          "CustomerReviews.StarRating",
          "CustomerReviews.Count",
          "Images.Primary.Large",
          "Offers.Listings.Availability.Message",
          "Offers.Listings.Availability.Type",
          "Offers.Listings.IsBuyBoxWinner",
        ],
      };

      try {
        const response = await this.signedAmazonRequest(
          "paapi5/getitems",
          payload,
          settings,
        );

        if (!response.ok) {
          const errorText = await response.text();
          console.error(
            `❌ Failed for ASIN ${asin} with status ${response.status}:`,
            errorText,
          );
          continue;
        }

        const json = await response.json();
        const item = json?.ItemsResult?.Items?.[0];

        if (item) {
          results.push({
            asin: item.ASIN,
            title: item.ItemInfo?.Title?.DisplayValue,
            description: (item.ItemInfo?.Features?.DisplayValues ?? []).join("; "),
            imageUrl: item.Images?.Primary?.Large?.URL,
            price: item.Offers?.Listings?.[0]?.Price?.DisplayAmount,
            rating: item.CustomerReviews?.StarRating?.AverageRating,
            reviewCount: item.CustomerReviews?.Count,
            availabilityType: item.Offers?.Listings?.[0]?.Availability?.Type,
            availabilityMsg: item.Offers?.Listings?.[0]?.Availability?.Message,
            isBuyBoxWinner: item.Offers?.Listings?.[0]?.IsBuyBoxWinner ?? false,
            buyBoxPrice: item.Offers?.Listings?.[0]?.Price?.DisplayAmount,
            affiliateLink: `https://www.amazon.com/dp/${item.ASIN}?tag=${settings.partnerId}`,
          });
        }
        
    } catch (error) {
      console.error(`❌ Error for ASIN ${asin}:`, error);
    }

    await new Promise((resolve) => setTimeout(resolve, 1100));
  }
} catch (err) {
  console.error("Error during GetItems:", err);
}

return results;

  /**
   * Calculate a score for how closely a product title matches the keyword.
   * This is a simple heuristic that counts how many words in the keyword
   * appear in the product title (case–insensitive).
   */
  private scoreProduct(product: AmazonProduct, keyword: string): number {
    const title = product.title.toLowerCase();
    let score = 0;
    for (const word of keyword.toLowerCase().split(" ")) {
      if (title.includes(word)) {
        score++;
      }
    }
    return score;
  }

  /**
   * Determine whether a product is considered a main product (i.e. not an accessory)
   * unless the primary search keyword explicitly suggests an accessory.
   */
  private isMainProduct(
    product: AmazonProduct,
    primaryKeyword: string,
  ): boolean {
    const title = product.title.toLowerCase();
    const accessoryIndicators = ["mount", "accessory", "installation kit"];

    // If the search keyword itself suggests an accessory, allow it.
    const primaryIsAccessory = accessoryIndicators.some((indicator) =>
      primaryKeyword.toLowerCase().includes(indicator),
    );
    if (primaryIsAccessory) {
      return true;
    }

    // Otherwise, exclude items whose title includes common accessory indicators.
    return !accessoryIndicators.some((indicator) => title.includes(indicator));
  }
}

export const amazonService = new AmazonService();
